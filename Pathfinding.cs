using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Pathfinding 
{

    public enum PathFinderStatus
    {
        NOT_INITIALIZED,
        SUCCESS,
        FAILURE,
        RUNNING
    }

    //abstract class that provides the base class for any type of vertex to implement in pathfinding problem
    //T is a datatype? Why do we need to create a datatype?
    abstract public class Node<T>
    {
        //store ref to T as Value. T is the data type, concrete implementation will use Vector2
        public T Value { get; set; }
        protected Node(T value) => Value = value;


        //get neighbors of THIS node. Function below
        abstract public List<Node<T>> GetNeighbors();
    }




    abstract public class PathFinder<T>
    {
        //this property holds the current status of PathFinderStatus
        //starts = to NOT_INITIALIZED
        #region Properties
        public PathFinderStatus Status
        {
            get;
            private set;

        } = PathFinderStatus.NOT_INITIALIZED;

        #endregion
        public Node<T> Start { get; set; }
        public Node<T> Goal { get; set; }




        //now we have a delegate that defines the cost
        //for moving between two nodes
        //HeuristicCost allows user to specify the function to use. 
        //NodeTraversal allows user to define the cost of moving between nodes
        public delegate float CostFunction(T a, T b);
        public CostFunction HeuristicCost { get; set; }
        public CostFunction NodeTraversalCost { get; set; }


        #region Delegates for action callbacks.
        // Some callbacks to handle on changes to the internal values.
        // these callbacks can be used by the game to display visually the
        // changes to the cells and lists.
        public delegate void DelegatePathFinderNode(PathFinderNode node);
        public DelegatePathFinderNode onChangeCurrentNode;
        public DelegatePathFinderNode onAddToOpenList;
        public DelegatePathFinderNode onAddToClosedList;
        public DelegatePathFinderNode onDestinationFound;

        public delegate void DelegateNoArgument();
        public DelegateNoArgument onStarted;
        public DelegateNoArgument onRunning;
        public DelegateNoArgument onFailure;
        public DelegateNoArgument onSuccess;
        #endregion




        //This class is a node of the tree generated by the pathfinder when searching. 
        // This class equates to a node in a the tree generated
        // by the pathfinder in its search for the most optimal
        // path. Do not confuse this with the Node class on top.
        // This class encapsulates a Node and hold other attributes
        // needed for the search traversal.
        // The pathfinder creates instances of this class at runtime
        // while doing the search. It is not abstract so it can be instantiated (new).
        public class PathFinderNode
        {
            //parent of this node
            public PathFinderNode Parent { get; set; }

            //this Node
            public Node<T> Location { get; set; }

            //define costs
            public float FCost { get; set; }
            //GCost is the total accumulated cost until the current node
            public float GCost { get; set; }
            //Heuristic cost
            public float HCost { get; set; }


            //constructor
            public PathFinderNode(Node<T> location, PathFinderNode parent, float gCost, float hCost)
            {
                Location = location;
                Parent = parent;
                GCost = gCost;
                HCost = hCost;
            }

            //set up gCost
            public void SetGCost(float c)
            {
                GCost = c;
                FCost = GCost + HCost;
            }
        }





        //access current node pathfinder is on
        public PathFinderNode CurrentNode { get; private set; }



        #region open and closed lists & functions
        //open list contains nodes we Want to explore, closed contains nodes we Have explored
        //need to sort open list by minimum costs so we explore those first
        protected List<PathFinderNode> mOpenList = new List<PathFinderNode> { };
        protected List<PathFinderNode> mClosedList = new List<PathFinderNode> { };
        #endregion


        //below: implement a function that returns the node with the least cost, on path from start to goal
        protected PathFinderNode GetLeastCostNode(List<PathFinderNode> nodeList)
        {
            int bestIndex = 0;
            float bestPriority = nodeList[0].FCost;

            for (int i = 1; i < nodeList.Count; i++)
            {
                if (bestPriority > nodeList[i].FCost)
                {
                    bestPriority = nodeList[i].FCost;
                    bestIndex = i;
                }
            }

            PathFinderNode node = nodeList[bestIndex];
            return node;
        }


        //check if a node of a specific value of type T is in a list
        //if so return index. if not return -1
        protected int IsInList(List<PathFinderNode> nodeList, T cell)
        {
            for (int i = 0; i < nodeList.Count; i++)
            {
                if (EqualityComparer<T>.Default.Equals(nodeList[i].Location.Value, cell))
                {
                    return i;
                }
            }
            return -1;
        }




        //now we can implement pathfinding in two stages
        //In our first stage, we initialize the PathFinder by setting all the necessary parameters.
        //Then in the second stage, we implement the inner loop of the search as a Step method.

        //first, check if already searching. if so, return false. Otherwise, reset vars and initialize
        public bool Initialize(Node<T> start, Node<T> goal)
        {
            if (Status == PathFinderStatus.RUNNING)
            {
                return false;
            }

            Reset();

            //start is where the AI is on the map at the start of pathfinding process
            Debug.Log("Start node =  " + start.Value + "     End = " + goal.Value);
            Start = start;
            Goal = goal;

            //calc H cost for start node
            float H = HeuristicCost(Start.Value, Goal.Value);
            //create root node with parent as null
            PathFinderNode root = new PathFinderNode(Start, null, 0f, H);
            //add the root node to open list
            mOpenList.Add(root);
            //set current node to root
            CurrentNode = root;
            
            //inform caller if delegates are not null
            onChangeCurrentNode?.Invoke(CurrentNode);
            onStarted?.Invoke();

            Status = PathFinderStatus.RUNNING;
            return true;
        }


        public void Reset()
        {
            if (Status == PathFinderStatus.RUNNING)
            {
                // Cannot reset path finder. Path finding in progress.
                return;
            }

            CurrentNode = null;

            mOpenList.Clear();
            mClosedList.Clear();

            Status = PathFinderStatus.NOT_INITIALIZED;
        }



        //Stage 2: Step until failure or goal
        //take a step. The user must continuously call
        //this method until there is a success or failure (use a While loop based on Status==RUNNING)
        public PathFinderStatus Step()
        {
            //trying to end early if it's not a close cell:
            //if(CurrentNode.Location.Value.x )


            //add current node to closed list
            if (!mClosedList.Contains(CurrentNode))
            {
                mClosedList.Add(CurrentNode);
                //onAddToClosedList?.Invoke(CurrentNode);
            }

            if (mOpenList.Count == 0)
            {
                //exhaused search, no more options
                Status = PathFinderStatus.FAILURE;
                onFailure?.Invoke();
                Debug.Log("Failed to find path");
                return Status;
            }


            //get least cost node from open list
            //becomes our new current node
            CurrentNode = GetLeastCostNode(mOpenList);
            //onChangeCurrentNode?.Invoke(CurrentNode);

            //remove it from open list
            mOpenList.Remove(CurrentNode);

            //check if node is the goal cell
            if(EqualityComparer<T>.Default.Equals(CurrentNode.Location.Value, Goal.Value))
            {
                Status = PathFinderStatus.SUCCESS;
                onDestinationFound?.Invoke(CurrentNode);
                onSuccess?.Invoke();
                return Status;
            }

            //we are not in the goal cell, so keep going
            //find nieghbors. Only adds walkable nodes
            List<Node<T>> neighbors = CurrentNode.Location.GetNeighbors();


            //traverse each neighbor for possible expansion
            foreach(Node<T> cell in neighbors)
            {
                //break out the algorithm method so we can mess with
                //different algs to see which one we like for the 
                //game we are designing.
                
                AlgorithmSpecificImplementation(cell);
            }

            Status = PathFinderStatus.RUNNING;
            onRunning?.Invoke();
            return Status;

        }



        abstract protected void AlgorithmSpecificImplementation(Node<T> cell);


    }


    public class AStarPathFinder<T> : PathFinder<T>
    {
        protected override void AlgorithmSpecificImplementation(Node<T> cell)
        {
            //check if node is in closed list - if so, ignore it
            if (IsInList(mClosedList, cell.Value) == -1)
            {
                //cell is not in the closed list (since our index came back defaulted)

                //calc the cost of the node from its parent
                //G cost is the CUMULATIVE cost from start til now
                //so to get G, GCost += currentNode to this cell cost

                float G = CurrentNode.GCost + NodeTraversalCost(CurrentNode.Location.Value, cell.Value);
                float H = HeuristicCost(cell.Value, Goal.Value);

                //check if cell is already in open list
                int indOpenList = IsInList(mClosedList, cell.Value);
                if (indOpenList == -1)
                {
                    //cell is not in open list, so add it
                    PathFinderNode node = new PathFinderNode(cell, CurrentNode, G, H);
                    mOpenList.Add(node);
                    onAddToOpenList?.Invoke(node);
                }
                else
                {
                    //if the cell is already in the open list, check if
                    //G cost is < the Gcost of the one in the list (if it changed)
                    float oldG = mOpenList[indOpenList].GCost;
                    if(G < oldG)
                    {
                        //change parent and update cost
                        mOpenList[indOpenList].Parent = CurrentNode;
                        mOpenList[indOpenList].SetGCost(G);
                        onAddToOpenList?.Invoke(CurrentNode);
                    }
                }


            }
        }
    }

    //Greedy first works best for regular grids
    public class GreedyPathFinder<T> : PathFinder<T>
    {
        protected override void AlgorithmSpecificImplementation(Node<T> cell)
        {
            if (IsInList(mClosedList, cell.Value) == -1)
            {

                //Greedy best-first does doesn't include the G cost
                float G = 0.0f;
                float H = HeuristicCost(cell.Value, Goal.Value);

                // Check if the cell is already there in the open list.
                int idOList = IsInList(mOpenList, cell.Value);
                if (idOList == -1)
                {
                    // The cell does not exist in the open list.
                    // We will add the cell to the open list
                    
                    PathFinderNode n = new PathFinderNode(cell, CurrentNode, G, H);
                    mOpenList.Add(n);
                    onAddToOpenList?.Invoke(n);
                }
                else
                {
                    // if the cell exists in the openlist then check if the G cost is less than the 
                    // one already in the list.
                    float oldG = mOpenList[idOList].GCost;
                    if (G < oldG)
                    {
                        // change the parent and update the cost to the new G
                        mOpenList[idOList].Parent = CurrentNode;
                        mOpenList[idOList].SetGCost(G);
                        onAddToOpenList?.Invoke(mOpenList[idOList]);
                    }
                }
            }
        }
    }


}


